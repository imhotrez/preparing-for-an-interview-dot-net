https://youtu.be/JCSv9RDP_lY?list=PL_2U-8LFWSaUSXOhJupmRomYoNAwCeyww

План запроса - дерево вычислений.
Любой запрос можно записать в виде выражения на языке реляционной алгебры.
Арифметические операции работают с числами, а операции реляционной алгебры работают с можествами строк.
Реляционная алгебра - это алгебра над множествами строк.
Каждая операция принимает на вход одно или два множества и возвращает новое множество строк.
#### Фильтрация

Для оценки затрат ресурсов на сканирование нужно посчитать кол-во операций чтения данных для перебора всех строк таблицы
Данные на диске организованы в блоки (страницы) ~1000 строк таблицы. Размер блока при настройке СУБД можно подобрать под размер буфера чтения ОС.
- Seq Scan (Full Scan) - последовательное сканирование
- Parallel seq scan (Full Scan) параллельное последовательное сканирование
- Index scan Сканирование по индексу
	Один узел B-дерева индекса может содержать ~1000 ключей
#### Соединение таблиц

###### Hash Join
Для меньшего из двух множеств строк строится хэш-таблица (ключ - значение колонки из условия соединения, значение - ссылка на строку адрес блока + адрес строки)
Сложность O(n)
###### Merge Join
Удобен когда есть индексы в колонках условия соединения
Сложность O(n)
###### Nested Loop - Вложенный цикл
Для декартова произведения множеств или для соединения по условию неравенства.
Сложность O(n^2)

Какой алгоритм выгоднее - зависит от размеров таблиц, статистики значений в колонках соединений и наличия индексов. 

Для определения оптимального плана СУБД собирает статистику по данным.
- Кол-во строк 
- Кол-во блоков
- Средний размер строки
- Глубина дерева индекса
- Фактор кластеризации
- Мин и Макс значения
СУБД кэширует созданные планы для переиспользования
Часто запрашиваемые блоки данных таблиц и индексов кэшируются

План запроса - дерево вычислений, в котором для каждого узла указана стоимость вычисления части дерева. В корне дерева указывается итоговая оценка стоимости. Задача СУБД найти план с минимальной стоимостью. Оценка стоимости может состоять из вдух чисел: время получения первой записи и время получения всех записей. Оценка дается в относительных единицах. Для ускорения выполнения запроса нужно найти в древе вычислений ботл-нек - узел, вносящий наибольший вклад в стоимость выполнения запроса и работать с ним. И здесь возможны два пути:
- Менять определение структуры данных.
- Менять логику приложения

Если узкое место - сканирование СУБД может не применять индекс, если условия поиска не подходят к индексу. Например, составной индекс из трех колонок будет работать только в случае использования логического И для предикатов трех колонок. Для логического ИЛИ нужен отдельный индекс на каждую из колонок.
Если индекс создан по значению колонки, а поиск ведется по выражению, использующему это значение, нужно заменить текущий индекс по значению на индекс по выражению.

Так же узким местом может быть сортировка данных. Сортировка или группировка могут включаться в план запроса даже если в SQL нет команд ORDER BY или GROUP BY.
Например DISTINCT приводит к внутренней сортировке или группировке данных, в зависимости от статистики.

Расчет аггрегации, например подсчет числа страниц. Можно изменить приложение так, чтобы кол-во страниц вычислялось только 1 раз или воспользоваться таблицами аггрегации.

Если есть задача удалять данные порциями - поможет разделение таблицы на партиции. Например по суткам, если данные удаляются за все сутки. Удаление будет происходить через DROP PARTITION. 

Колоночная организация таблицы.
